package ecc_utils;

import ecc_classes.*;

public class ECC_Utils {
	public static Point calculateNP(final EllipticCurve myCurve, final Point P1, final int n) {
		if (myCurve == null || P1 == null)
			throw new IllegalArgumentException("Curve or P1 is null");
		if (P1.isPointAtInfinity())
			return P1;
		Point nP = P1;
		for (int x = 1; x < n; x++)
			nP = nP.plus(P1, myCurve);
		return nP;
	} // end calculateP2

	public static int findInverseModP(final int num, final int p) {
		int a = num % p;
		for (int x = 1; x < p; x++)
			if ((a * x) % p == 1)
				return x;
		return 1;
	}
	// This code is contributed by Nikita Tiwari.
	// Found at:
	// https://www.geeksforgeeks.org/multiplicative-inverse-under-modulo-m/

	public static int findSqrtModP(final int num, final int p) {
		int a = num % p;
		for (int i = 0; i < p; i++) {
			if (i * i == a)
				return i;
		}
		return 0;
	} // end findSqrtModP

	public static int makePosModP(final int num, final int p) {
		int a = num % p;
		if (a < 0)
			return a += p;
		else
			return a;
	} // end makePosModP

	public static int findCurveOrder(final EllipticCurve myCurve) {
		int distinctPoints = 0;
		int order = 0;
		Point[] pointArray = new Point[myCurve.getP()];

		// put all possible points in pointArray
		for (int x = 0; x < pointArray.length; x++) {
			Point temp = new Point(x, Math.sqrt(Math.pow(x, 3) - myCurve.getA() * x + myCurve.getB()), false)
					.reduceModp(myCurve.getP());
			if (myCurve.hasPoint(temp)) // y = sqrt(x^3 + Ax + B)
				pointArray[x] = temp;
		}

		// if point was already recorded, set that array element to null
		for (int j = 0; j < pointArray.length; j++) {
			if (arrayContains(pointArray, j, pointArray[j]))
				pointArray[j] = null;
		}

		// count all non null points
		for (int j = 0; j < pointArray.length; j++) {
			if (pointArray[j] == null) {
			} else
				distinctPoints++;
		}

		order = 2 * distinctPoints;
		myCurve.setOrder(order);
		return order; // count points y>0 and y<0
	} // end findCurveOrder

	public static boolean arrayContains(final Point[] pointArray, final int upTo, final Point thisPoint) {
		for (int i = 0; i < upTo; i++) {
			if (pointArray[i] == thisPoint)
				return true;
		}
		return false;
	} // end arrayContains

	public static int findPointOrder(final EllipticCurve myCurve, final Point generator) {
		int curveOrder = myCurve.getOrder();
		int[] divisors = new int[myCurve.getP()];
		Point temp = null;

		// find all divisors of group order
		divisors[0] = 0;
		for (int i = 1; i < divisors.length; i++) {
			if (curveOrder % i == 0)
				divisors[i] = i;
			else
				divisors[i] = 0;
		}

		// find smallest value that is order of subgroup
		for (int i = 0; i < divisors.length; i++) {
			if (divisors[i] != 0) {
				temp = calculateNP(myCurve, generator, divisors[i]);
				if (temp.isPointAtInfinity())
					return divisors[i];
			}
		}

		return 0;
	} // end findPointOrder
/*
	public static Point[] generateSubgroup(final EllipticCurve myCurve, final Point generator) {
		Point Pout = generator;
		Point[] firstArray = new Point[myCurve.getP()];
		Point[] secondArray = new Point[myCurve.getP()];
		int i = 0;
		boolean contain = false;
		int last = 0;
		System.out.print("Subgroup generated by " + "(" + (int) Pout.getx() + ", " + (int) Pout.gety() + ") " + "is: ");

		// get all possible points generated by generator
		while (!Pout.isPointAtInfinity() && i < firstArray.length) {
			Pout = Pout.plus(generator, myCurve);
			firstArray[i] = Pout;
			i++;
		}

		// ensure no repeats
		for (int j = 0; j < myCurve.getP(); j++) {
			contain = false;

			// search to find if current place in firstArray already is in secondArray
			if(SearchUtils.linearSearch(secondArray, firstArray[j]) == -1) // TODO: FInish this
			//for (int k = 0; k < last; k++) {
				//if (firstArray[j].equals(secondArray[k]))
				
					contain = true;
			}

			if (!contain) {
				secondArray[last] = firstArray[j];
				last++;
			}

			j++;
		}

		for (int m = 0; m < last - 1; m++) {
			System.out.print("(" + (int) secondArray[m].getx() + ", " + (int) secondArray[m].gety() + ") ");
		}

		System.out.println();
		System.out.println("With repeats: ");
		for (Point point : firstArray) {
			System.out.print("(" + (int) point.getx() + ", " + (int) point.gety() + ") ");
		}
		return secondArray;
	} // end generateSubgroup
	*/
	
	public static void printArray(final Point [] array) {
		for(Point p: array) {
			if(p != null)
				System.out.print("(" + (int) p.getx() + ", " + (int) p.gety() + ")");
		}
		System.out.println();
		System.out.println();
	} // end printArray

} // end class
